#include <stdio.h>
#include <stdarg.h>
#include <gmp.h>
#include <stdlib.h>
#include <memory.h>
#include <openssl/aes.h>



void decifraComChave(unsigned char *key, unsigned char *cifrado){
    //FILE *fpChar = fopen("TextoClaroChar.txt", "w");
    //FILE *fpChar = fopen("TextoClaroHex.txt", "w");

    //unsigned char cifrado[] = {0x5D, 0x80, 0xB2, 0x2B, 0x7A, 0xE8, 0xEC, 0xD2, 0xFE, 0x85, 0xDB, 0x34, 0xAF, 0x46, 0x43, 0x60, 0x69, 0xF1, 0x95, 0x9B, 0x24, 0x99, 0x8C, 0x56, 0x90, 0x78, 0xBD, 0xB9, 0xB1, 0x37, 0xE7, 0xB7, 0xC0, 0x98, 0xA1, 0x86, 0x62, 0x73, 0xC2, 0x19, 0xEA, 0xAF, 0x29, 0x6B, 0x68, 0xEE, 0x22, 0x45, 0x65, 0xA3, 0xD7, 0x04, 0xBD, 0xEC, 0x51, 0x63, 0x8A, 0x88, 0x00, 0x02, 0xDC, 0x61, 0x88, 0xA9, 0x7D, 0x00, 0x7F, 0xD1, 0xD4, 0xF5, 0x8C, 0x27, 0x94, 0x01, 0x72, 0x72, 0x43, 0x3F, 0x72, 0x35, 0xC3, 0x13, 0x44, 0x84, 0x13, 0x74, 0xF9, 0x57, 0x48, 0x5B, 0x39, 0xAA, 0x8D, 0x3D, 0xF4, 0xA2, 0xC6, 0xDE, 0x43, 0x32, 0x40, 0x5B, 0xE5, 0x1C, 0x06, 0x5D, 0x38, 0x10, 0x68, 0x40, 0x67, 0x4C, 0x77, 0x5C, 0x34, 0x3D, 0x80, 0x68, 0xC5, 0xAE, 0xE9, 0x53, 0x27, 0xB5, 0x7D, 0xF0, 0x95, 0x5C, 0x4C, 0x8B, 0x34, 0x0B, 0x5C, 0x98, 0x48, 0x54, 0x0D, 0xCD, 0x04, 0x94, 0xBA, 0xAB, 0x2A, 0xBB, 0xDC, 0x8D, 0x4D, 0x92, 0x10, 0x5F, 0x75, 0x7C, 0x02, 0xB6, 0xBB, 0x31, 0x89, 0x29, 0x8B, 0xE1, 0x72, 0xFF, 0x4D, 0x6B, 0x40, 0x43, 0x51, 0x34, 0xFC, 0x67, 0x70, 0x47, 0xC4, 0x4D, 0x44, 0x0C, 0x3D, 0x8D, 0x5E, 0x62, 0xFD, 0x8A, 0x23, 0x40, 0x08, 0x5C, 0x93, 0xAF, 0xC5, 0x3E, 0xF7, 0x33, 0xFB, 0xA2, 0x35, 0x55, 0x3C, 0x89, 0xCC, 0xDF, 0xF3, 0xD4, 0x78, 0xBA, 0xF4, 0x67, 0xD3, 0xF1, 0x58, 0x59, 0x64, 0x3D, 0xF3, 0xCD, 0x2B, 0xFA, 0x74, 0xA5, 0x61, 0xF8, 0xA8, 0xF8, 0x22, 0xAE, 0x8F, 0xF5, 0xF3, 0x82, 0x7B, 0xBA, 0x50, 0xAF, 0xC3, 0x9C, 0xB2, 0xE3, 0x90, 0xCA, 0xC2, 0x3A, 0x2A, 0x9A, 0x29, 0x10, 0x72, 0xE2, 0x11, 0x86, 0xD5, 0xE1, 0x44, 0xCA, 0xB7, 0xB3, 0xFE, 0x06, 0xEB, 0x0D, 0x68, 0xB2, 0x7D, 0x5B, 0xD8, 0xE0, 0xA2, 0xEA, 0x37, 0xAD, 0x3A, 0xEC, 0x4F, 0x1E, 0x65, 0x72, 0x64, 0xF5, 0x3D, 0x53, 0xC4, 0x5C, 0x81, 0xDF, 0xD9, 0xDA, 0xE9, 0xA8, 0xB1, 0xF3, 0x60, 0x6E, 0x22, 0x9B, 0x6F, 0x3D, 0xB0, 0xEC, 0x43, 0x94, 0x91, 0x01, 0x11, 0x0E, 0x76, 0x67, 0xAB, 0x33, 0xA8, 0x62, 0xB8, 0x2C, 0x5C, 0xB4, 0x46, 0x94, 0x22, 0x40, 0x99, 0xE2, 0xC8, 0xAA, 0x63, 0x70, 0x4A, 0xCC, 0xDB, 0x22, 0xCD, 0xCE, 0x26, 0x6B, 0x63, 0x6C, 0xC4, 0x00, 0x48, 0x5C};
    AES_KEY chave;

    unsigned char *blocos[92];

    unsigned char blocoDecifrar[16];
    unsigned char bloco_claro[16];
    unsigned char bloco_claro_print[17];

    for(int linha=0; linha<92; linha++){
        blocos[linha] = &cifrado[linha*16];
    }

    AES_set_decrypt_key(key, 128, &chave);

    for(int blocoAtual = 0; blocoAtual<92; blocoAtual++){

        memcpy(blocoDecifrar, blocos[blocoAtual], 16);
        AES_ecb_encrypt(blocoDecifrar, bloco_claro, &chave, AES_DECRYPT);
        memcpy(bloco_claro_print, bloco_claro, 16);
        bloco_claro_print[16] = "\0";

        printf("%s\n", bloco_claro_print);

    }
}


int main(){

    int exist;
    mpz_t gInv, g, n, X, Y, inversoTeste, K, x, KeyTest, AESProdKey, Div256;
    char nRep[] = "340282366920938463463374607431768211297";
    char gRep[] = "339661812359158752487805590648382727301";
    char XRep[] = "217752919763112980997405005489123510636"; // x * g mod n
    char YRep[] = "298233162195654143916628869899206392532"; // y * g mod n
    char binKey[200];
    int AESKey[16];

    //mpz_init_set_str (a, n, 10);	/* Assume decimal integers */
    //mpz_init_set_str (b, g, 10);	/* Assume decimal integers */
    //mpz_add (a, a, b);

    mpz_init_set_str(g, gRep, 10);
    mpz_init_set_str(n, nRep, 10);
    mpz_init_set_str(X, XRep, 10);
    mpz_init_set_str(Y, YRep, 10);
    mpz_init(gInv);
    mpz_init(inversoTeste);
    mpz_init(K);
    mpz_init(x);
    mpz_init(KeyTest);
    mpz_init(AESProdKey);
    mpz_init_set_str(Div256, "256", 10);

    exist = mpz_invert(gInv, g, n);

    if(exist == 0)
        printf("Nao existe\n");
    else{
        printf("%s\n", mpz_get_str(NULL, 10, gInv));
        mpz_mul(inversoTeste, g, gInv);
        mpz_mod(inversoTeste, inversoTeste, n);
        printf("%s\n", mpz_get_str(NULL, 10, inversoTeste));
    }

    mpz_mul(K, X, Y);
    mpz_mul(K, K, gInv);
    mpz_mod(K, K, n);
    printf("%s\n", mpz_get_str(NULL, 10, K));

    mpz_mul(x, X, gInv);
    mpz_mod(x, x, n);
    mpz_mul(KeyTest, x, Y);
    mpz_mod(KeyTest, KeyTest, n);
    //mpz_get_str(binKey, 2, KeyTest);
    //printf("%s\n",binKey);
    //printf("%c\n", binKey[127]);

    for(int i=0; i<16; i++){
        mpz_mod(AESProdKey, K, Div256);
        AESKey[i] = (int) mpz_get_ui(AESProdKey);
        mpz_cdiv_q(K, K, Div256);
        printf("%d\n", AESKey[i]);
    }
    //mpz_mod(AESProdKey, K, Div256);
    //printf("%s\n", mpz_get_str(NULL, 10, AESProdKey));

    FILE *fp = fopen("/Users/Airton/Dev/Seguranca/DHellman/arquivo1.txt", "r+");

    char hexDigit[3];
    int Arquivo[1472];
    char *endP;
    char textoCifrado[16];
    for(int i=0; i<92; i++){
        for(int j=0; j<17; j++) {
            if(j<16) {
                fread(hexDigit, sizeof(char), 2 * sizeof(char), fp);
                hexDigit[2] = 0;
                //printf("%s\n", hexDigit);
                Arquivo[16 * i + j] = strtol(hexDigit, &endP, 16);
            }
            else{
                fread(hexDigit, sizeof(char), 1* sizeof(char), fp);
            }
        }
    }
    unsigned char AESKEYTODEC[16];
    unsigned char TextoCripto[1472];
    for(int i=0; i<16; i++){
        AESKEYTODEC[i] = (unsigned char) AESKey[i];
    }
    for(int i=0; i<1472; i++){
        TextoCripto[i] = (unsigned char) Arquivo[i];
    }

    decifraComChave(AESKEYTODEC, TextoCripto);





    //printf("%s\n", mpz_get_str(NULL, 10, a));
    //return 0;

    return 0;
}